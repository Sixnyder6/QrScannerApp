uniform float2 iResolution;
uniform float iTime;
uniform float2 iPointer; // Interaction point (optional)

// METAPHOR PARAMETERS
uniform float flowSpeed;      // How fast the gas moves
uniform float complexity;     // Turbulence of the internal fluid
uniform float3 nebulaColorA;  // Deep core color
uniform float3 nebulaColorB;  // Highlight/Edge color
uniform float density;        // Opacity/Thickness of the gas

// UTIL: Pseudo-random hash
half hash(float2 p) {
    p = fract(p * 0.3183099 + 0.1);
    p *= 17.0;
    return fract(p.x * p.y * (p.x + p.y));
}

// UTIL: 2D Noise
half noise(float2 x) {
    float2 i = floor(x);
    float2 f = fract(x);
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// CORE: Fractal Brownian Motion (Unrolled for performance)
half fbm(float2 p) {
    half v = 0.0;
    half a = 0.5;
    float2 shift = float2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));

    // Octave 1
    v += a * noise(p); p = rot * p * 2.0 + shift; a *= 0.5;
    // Octave 2
    v += a * noise(p); p = rot * p * 2.0 + shift; a *= 0.5;
    // Octave 3 (Detail layer)
    v += a * noise(p);
    return v;
}

half4 main(float2 fragCoord) {
    // 1. Normalize and fix aspect ratio
    float2 uv = fragCoord.xy / iResolution.xy;
    float2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;

    // 2. DOMAIN WARPING (The "Fluid" Metaphor)
    // We don't move the color; we move the space the color lives in.

    float t = iTime * flowSpeed;

    // Warp Layer 1: Base Flow
    float2 q = float2(0.0);
    q.x = fbm(p + 0.00 * t);
    q.y = fbm(p + float2(1.0));

    // Warp Layer 2: Turbulence (The recursive warp)
    float2 r = float2(0.0);
    r.x = fbm(p + 1.0 * q + float2(1.7, 9.2) + 0.15 * t);
    r.y = fbm(p + 1.0 * q + float2(8.3, 2.8) + 0.126 * t);

    // 3. COLOR SYNTHESIS
    // Calculate final noise value based on the double-warped coordinate 'r'
    float f = fbm(p + complexity * r);

    // Mix colors based on density and noise value
    // We mix the noise value with itself to create sharper ridges (the "smoke" edges)
    float3 color = mix(nebulaColorA, nebulaColorB, clamp((f * f) * 4.0, 0.0, 1.0));

    // Add "Deep Space" darkness
    color = mix(color, float3(0.0, 0.0, 0.1), clamp(length(q), 0.0, 1.0));

    // 4. CINEMATIC POLISH
    // Subtle Chromatic Aberration at edges (simulating glass refraction)
    float aberrationStrength = 0.02 * length(uv - 0.5);
    color.r += fbm(p + r + aberrationStrength);
    color.b -= fbm(p + r - aberrationStrength);

    // Contrast curve (Filmic tone mapping approximation)
    color = color * color * (3.0 - 2.0 * color);

    // Vignette
    float vig = 1.0 - length(uv - 0.5) * 0.5;
    color *= vig;

    // 5. ALPHA/DENSITY
    // Ensure the alpha channel reflects the density for potential compositing
    half alpha = 1.0;

    return half4(color * density, alpha);
}